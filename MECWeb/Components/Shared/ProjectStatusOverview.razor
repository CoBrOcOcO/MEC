@using MECWeb.DbModels.Workflow
@using MECWeb.DbModels.Project
@using Microsoft.EntityFrameworkCore

@inject IDbContextFactory<ApplicationDbContext> DbContextFactory

@implements IDisposable

<!-- PROJECT STATUS OVERVIEW COMPONENT -->
@if (workflows.Any())
{
    <MudPaper Class="pa-4 mb-4" Elevation="2" Style="background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);">
        <MudStack Spacing="3">
            <MudText Typo="Typo.h6" Color="Color.Primary" Style="font-weight: 600;">
                <MudIcon Icon="@Icons.Material.Filled.Dashboard" Class="mr-2" />
                Projekt-Status Übersicht
            </MudText>

            <!-- Status Progress Bar -->
            <MudStack Row Spacing="3" AlignItems="AlignItems.Center" Justify="Justify.Center" Class="my-2">
                <!-- Hardware Status -->
                <MudStack AlignItems="AlignItems.Center" Spacing="1">
                    <MudChip T="string"
                             Size="Size.Medium"
                             Color="@GetHardwareStatusColor()"
                             Variant="Variant.Filled"
                             Icon="@Icons.Material.Filled.Computer"
                             Class="px-4 py-3 font-weight-bold"
                             Style="@GetHardwareStatusStyle()">
                        Hardware
                    </MudChip>
                    <MudText Typo="Typo.caption" Color="Color.Secondary" Align="Align.Center">
                        @GetHardwareStatusText()
                    </MudText>
                </MudStack>

                <!-- Arrow -->
                <MudIcon Icon="@Icons.Material.Filled.ArrowForward" Color="Color.Secondary" Size="Size.Medium" />

                <!-- Software Status -->
                <MudStack AlignItems="AlignItems.Center" Spacing="1">
                    <MudChip T="string"
                             Size="Size.Medium"
                             Color="@GetSoftwareStatusColor()"
                             Variant="Variant.Filled"
                             Icon="@Icons.Material.Filled.Build"
                             Class="px-4 py-3 font-weight-bold"
                             Style="@GetSoftwareStatusStyle()">
                        Software
                    </MudChip>
                    <MudText Typo="Typo.caption" Color="Color.Secondary" Align="Align.Center">
                        @GetSoftwareStatusText()
                    </MudText>
                </MudStack>

                <!-- Arrow -->
                <MudIcon Icon="@Icons.Material.Filled.ArrowForward" Color="Color.Secondary" Size="Size.Medium" />

                <!-- Purchase Status -->
                <MudStack AlignItems="AlignItems.Center" Spacing="1">
                    <MudChip T="string"
                             Size="Size.Medium"
                             Color="@GetPurchaseStatusColor()"
                             Variant="Variant.Filled"
                             Icon="@Icons.Material.Filled.ShoppingCart"
                             Class="px-4 py-3 font-weight-bold"
                             Style="@GetPurchaseStatusStyle()">
                        Einkauf
                    </MudChip>
                    <MudText Typo="Typo.caption" Color="Color.Secondary" Align="Align.Center">
                        @GetPurchaseStatusText()
                    </MudText>
                </MudStack>

                <!-- Arrow -->
                <MudIcon Icon="@Icons.Material.Filled.ArrowForward" Color="Color.Secondary" Size="Size.Medium" />

                <!-- Installation Status -->
                <MudStack AlignItems="AlignItems.Center" Spacing="1">
                    <MudChip T="string"
                             Size="Size.Medium"
                             Color="@GetInstallationStatusColor()"
                             Variant="Variant.Filled"
                             Icon="@Icons.Material.Filled.Construction"
                             Class="px-4 py-3 font-weight-bold"
                             Style="@GetInstallationStatusStyle()">
                        Installation
                    </MudChip>
                    <MudText Typo="Typo.caption" Color="Color.Secondary" Align="Align.Center">
                        @GetInstallationStatusText()
                    </MudText>
                </MudStack>
            </MudStack>

            <!-- Progress Bar -->
            <MudProgressLinear Color="Color.Success"
                               Value="@_animatedProgress"
                               Size="Size.Large"
                               Rounded="true"
                               Class="my-2"
                               Style="height: 12px;" />

            <!-- Overall Progress Information -->
            <MudDivider />
            <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                <MudStack Row Spacing="3">
                    <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Text" Icon="@Icons.Material.Filled.Computer">
                        @workflows.Count(w => w.WorkflowType == WorkflowType.BDR) BDR
                    </MudChip>
                    <MudChip T="string" Size="Size.Small" Color="Color.Secondary" Variant="Variant.Text" Icon="@Icons.Material.Filled.CameraAlt">
                        @workflows.Count(w => w.WorkflowType == WorkflowType.BV) BV
                    </MudChip>
                    <MudChip T="string" Size="Size.Small" Color="Color.Success" Variant="Variant.Text" Icon="@Icons.Material.Filled.CheckCircle">
                        @workflows.Count Gesamt
                    </MudChip>
                </MudStack>
                <MudChip T="string" Size="Size.Small" Color="Color.Success" Variant="Variant.Filled" Style="font-weight: 600;">
                    @GetCompletionPercentage()% abgeschlossen
                </MudChip>
            </MudStack>
        </MudStack>
    </MudPaper>
}
else if (IsLoading)
{
    <!-- Loading State -->
    <MudPaper Class="pa-4 mb-4" Elevation="2" Style="background-color: var(--mud-palette-background-grey);">
        <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
            <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true" />
            <MudText Typo="Typo.body2" Color="Color.Secondary">Projekt-Status wird geladen...</MudText>
        </MudStack>
    </MudPaper>
}
else
{
    <!-- No Workflows State -->
    <MudPaper Class="pa-4 mb-4" Elevation="2" Style="background-color: var(--mud-palette-background-grey);">
        <MudStack AlignItems="AlignItems.Center" Spacing="2">
            <MudIcon Icon="@Icons.Material.Filled.Info" Color="Color.Secondary" />
            <MudText Typo="Typo.body2" Color="Color.Secondary" Align="Align.Center">
                Noch keine Formulare für dieses Projekt erstellt.
            </MudText>
        </MudStack>
    </MudPaper>
}

@code {
    [Parameter] public Guid ProjectId { get; set; }
    [Parameter] public bool IsLoading { get; set; } = false;

    private List<DbWorkflow> workflows = new();
    private double _animatedProgress = 0;
    private System.Threading.Timer? _progressTimer;

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkflows();
    }

    private async Task LoadWorkflows()
    {
        try
        {
            using var context = await DbContextFactory.CreateDbContextAsync();

            workflows = await context.Workflow
                .AsNoTracking()
                .Where(w => w.ProjectId == ProjectId)
                .OrderBy(w => w.WorkflowType == WorkflowType.BDR ? 0 : 1)
                .ThenBy(w => w.Name)
                .ToListAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading workflows in ProjectStatusOverview: {ex.Message}");
            workflows = new List<DbWorkflow>();
        }
    }

    public async Task RefreshAsync()
    {
        await LoadWorkflows();
        StateHasChanged();
    }

    // ==================== HARDWARE STATUS ====================

    // Get hardware status color based on workflow states
    private Color GetHardwareStatusColor()
    {
        if (!workflows.Any()) return Color.Default;

        // Check for pending corrections affecting Hardware
        if (workflows.Any(w => w.HasPendingCorrection &&
            !string.IsNullOrEmpty(w.CorrectionPhase) &&
            w.CorrectionPhase.Contains("Hardware", StringComparison.OrdinalIgnoreCase)))
            return Color.Warning;

        // Dunkelgrün: Hardware was forwarded (Status >= Completed)
        if (workflows.All(w => w.Status >= WorkflowStatus.Completed))
            return Color.Dark;

        // Hellgrün: Hardware completed, ready for forwarding to Software
        // Alle Workflows haben mindestens SoftwareInProgress erreicht ABER noch nicht beim Einkauf
        if (workflows.All(w => w.Status >= WorkflowStatus.SoftwareInProgress) &&
            workflows.All(w => w.Status < WorkflowStatus.Completed))
            return Color.Success;

        // Orange: Hardware in progress - mindestens ein Workflow ist bei HardwareInProgress oder höher, aber nicht alle fertig
        if (workflows.Any(w => w.Status >= WorkflowStatus.HardwareInProgress))
            return Color.Warning;

        // Grau: Not started
        return Color.Default;
    }

    // Get hardware status style for dark green
    private string GetHardwareStatusStyle()
    {
        if (!workflows.Any()) return "";

        if (workflows.All(w => w.Status >= WorkflowStatus.Completed))
            return "background-color: #2e7d32 !important; box-shadow: 0 2px 8px rgba(46, 125, 50, 0.3);";

        return "box-shadow: 0 2px 8px rgba(0,0,0,0.1);";
    }

    // Get hardware status text
    private string GetHardwareStatusText()
    {
        if (!workflows.Any()) return "Ausstehend";

        // Check for corrections
        var correctionsCount = workflows.Count(w => w.HasPendingCorrection &&
            !string.IsNullOrEmpty(w.CorrectionPhase) &&
            w.CorrectionPhase.Contains("Hardware", StringComparison.OrdinalIgnoreCase));
        if (correctionsCount > 0) return $"Korrektur ({correctionsCount})";

        // Dunkelgrün: All forwarded
        if (workflows.All(w => w.Status >= WorkflowStatus.Completed))
            return "Weitergeleitet";

        // Hellgrün: All completed, ready for forwarding
        if (workflows.All(w => w.Status >= WorkflowStatus.SoftwareInProgress && w.Status < WorkflowStatus.Completed))
            return "Abgeschlossen";

        // Orange: In progress
        var completed = workflows.Count(w => w.Status >= WorkflowStatus.SoftwareInProgress);
        if (completed > 0) return $"{completed}/{workflows.Count}";

        return "Ausstehend";
    }

    // ==================== SOFTWARE STATUS ====================

    // Get software status color based on workflow states
    private Color GetSoftwareStatusColor()
    {
        if (!workflows.Any()) return Color.Default;

        // Check for pending corrections affecting Software
        if (workflows.Any(w => w.HasPendingCorrection &&
            !string.IsNullOrEmpty(w.CorrectionPhase) &&
            w.CorrectionPhase.Contains("Software", StringComparison.OrdinalIgnoreCase)))
            return Color.Warning;

        // Dunkelgrün: Software was forwarded (Status >= Completed)
        if (workflows.All(w => w.Status >= WorkflowStatus.Completed))
            return Color.Dark;

        // Hellgrün: Software completed, ready for forwarding to Purchase
        // Alle Workflows haben SoftwareCompleted erreicht ABER sind noch nicht beim Einkauf
        if (workflows.All(w => w.Status == WorkflowStatus.SoftwareCompleted))
            return Color.Success;

        // Orange: Software in progress - mindestens ein Workflow ist bei SoftwareInProgress oder höher
        if (workflows.Any(w => w.Status >= WorkflowStatus.SoftwareInProgress))
            return Color.Warning;

        // Grau: Not started (Status < SoftwareInProgress)
        return Color.Default;
    }

    // Get software status style for dark green
    private string GetSoftwareStatusStyle()
    {
        if (!workflows.Any()) return "";

        if (workflows.All(w => w.Status >= WorkflowStatus.Completed))
            return "background-color: #2e7d32 !important; box-shadow: 0 2px 8px rgba(46, 125, 50, 0.3);";

        return "box-shadow: 0 2px 8px rgba(0,0,0,0.1);";
    }

    // Get software status text
    private string GetSoftwareStatusText()
    {
        if (!workflows.Any()) return "Ausstehend";

        // Check for corrections
        var correctionsCount = workflows.Count(w => w.HasPendingCorrection &&
            !string.IsNullOrEmpty(w.CorrectionPhase) &&
            w.CorrectionPhase.Contains("Software", StringComparison.OrdinalIgnoreCase));
        if (correctionsCount > 0) return $"Korrektur ({correctionsCount})";

        // Dunkelgrün: All forwarded
        if (workflows.All(w => w.Status >= WorkflowStatus.Completed))
            return "Weitergeleitet";

        // Hellgrün: All completed, ready for forwarding
        if (workflows.All(w => w.Status == WorkflowStatus.SoftwareCompleted))
            return "Abgeschlossen";

        // Orange: In progress
        var completed = workflows.Count(w => w.Status >= WorkflowStatus.SoftwareCompleted);
        if (completed > 0) return $"{completed}/{workflows.Count}";

        return "Ausstehend";
    }

    // ==================== PURCHASE STATUS ====================

    // Get purchase status color based on workflow states
    private Color GetPurchaseStatusColor()
    {
        if (!workflows.Any()) return Color.Default;

        // Check for pending corrections in Purchase phase
        if (workflows.Any(w => w.HasPendingCorrection &&
            !string.IsNullOrEmpty(w.CorrectionPhase) &&
            w.CorrectionPhase.Contains("Purchase", StringComparison.OrdinalIgnoreCase)))
            return Color.Warning;

        // Dunkelgrün: Purchase was forwarded to installation (Status >= ForwardedToInstallation)
        if (workflows.All(w => w.Status >= WorkflowStatus.ForwardedToInstallation))
            return Color.Dark;

        // Hellgrün: All purchase completed, ready for forwarding to Installation
        // Alle beim Einkauf (Completed) UND alle als PurchaseCompleted markiert
        if (workflows.All(w => w.Status == WorkflowStatus.Completed) &&
            workflows.All(w => w.PurchaseCompleted))
            return Color.Success;

        // Orange: At purchase, in progress - beim Einkauf aber noch nicht alle erledigt
        if (workflows.Any(w => w.Status == WorkflowStatus.Completed))
            return Color.Warning;

        // Grau: Not at purchase yet (Status < Completed)
        return Color.Default;
    }

    // Get purchase status style for dark green
    private string GetPurchaseStatusStyle()
    {
        if (!workflows.Any()) return "";

        if (workflows.All(w => w.Status >= WorkflowStatus.ForwardedToInstallation))
            return "background-color: #2e7d32 !important; box-shadow: 0 2px 8px rgba(46, 125, 50, 0.3);";

        return "box-shadow: 0 2px 8px rgba(0,0,0,0.1);";
    }

    // Get purchase status text
    private string GetPurchaseStatusText()
    {
        if (!workflows.Any()) return "Ausstehend";

        // Check for corrections
        var correctionsCount = workflows.Count(w => w.HasPendingCorrection &&
            !string.IsNullOrEmpty(w.CorrectionPhase) &&
            w.CorrectionPhase.Contains("Purchase", StringComparison.OrdinalIgnoreCase));
        if (correctionsCount > 0) return $"Korrektur ({correctionsCount})";

        // Dunkelgrün: All forwarded to installation
        if (workflows.All(w => w.Status >= WorkflowStatus.ForwardedToInstallation))
            return "Weitergeleitet";

        // Hellgrün: All purchase completed, ready for forwarding
        if (workflows.All(w => w.Status == WorkflowStatus.Completed && w.PurchaseCompleted))
            return "Abgeschlossen";

        // Orange: At purchase, in progress
        if (workflows.Any(w => w.Status == WorkflowStatus.Completed))
        {
            var completed = workflows.Count(w => w.PurchaseCompleted);
            return $"{completed}/{workflows.Count}";
        }

        return "Ausstehend";
    }

    // ==================== INSTALLATION STATUS ====================

    // Get installation status color based on workflow states
    private Color GetInstallationStatusColor()
    {
        if (!workflows.Any()) return Color.Default;

        // Check for pending corrections in Installation phase
        if (workflows.Any(w => w.HasPendingCorrection &&
            !string.IsNullOrEmpty(w.CorrectionPhase) &&
            w.CorrectionPhase.Contains("Installation", StringComparison.OrdinalIgnoreCase)))
            return Color.Warning;

        // Dunkelgrün: Installation archived (Status = Archived)
        if (workflows.All(w => w.Status == WorkflowStatus.Archived))
            return Color.Dark;

        // Orange: At installation, in progress (Status = ForwardedToInstallation)
        if (workflows.Any(w => w.Status == WorkflowStatus.ForwardedToInstallation))
            return Color.Warning;

        // Grau: Not at installation yet (Status < ForwardedToInstallation)
        return Color.Default;
    }

    // Get installation status style for dark green
    private string GetInstallationStatusStyle()
    {
        if (!workflows.Any()) return "";

        if (workflows.All(w => w.Status == WorkflowStatus.Archived))
            return "background-color: #2e7d32 !important; box-shadow: 0 2px 8px rgba(46, 125, 50, 0.3);";

        return "box-shadow: 0 2px 8px rgba(0,0,0,0.1);";
    }

    // Get installation status text
    private string GetInstallationStatusText()
    {
        if (!workflows.Any()) return "Ausstehend";

        // Check for corrections
        var correctionsCount = workflows.Count(w => w.HasPendingCorrection &&
            !string.IsNullOrEmpty(w.CorrectionPhase) &&
            w.CorrectionPhase.Contains("Installation", StringComparison.OrdinalIgnoreCase));
        if (correctionsCount > 0) return $"Korrektur ({correctionsCount})";

        // Dunkelgrün: All archived
        if (workflows.All(w => w.Status == WorkflowStatus.Archived))
            return "Abgeschlossen";

        // Orange: At installation
        var atInstallation = workflows.Count(w => w.Status >= WorkflowStatus.ForwardedToInstallation);
        if (atInstallation > 0) return $"{atInstallation}/{workflows.Count}";

        return "Ausstehend";
    }

    // ==================== PROGRESS CALCULATION ====================

    // Calculate overall completion percentage
    private int GetCompletionPercentage()
    {
        if (!workflows.Any()) return 0;

        var totalSteps = workflows.Count * 7;
        var completedSteps = 0;

        foreach (var workflow in workflows)
        {
            if (workflow.Status >= WorkflowStatus.HardwareInProgress) completedSteps++;
            if (workflow.Status >= WorkflowStatus.SoftwareInProgress) completedSteps++;
            if (workflow.Status >= WorkflowStatus.SoftwareInProgress) completedSteps++;
            if (workflow.Status >= WorkflowStatus.SoftwareCompleted) completedSteps++;
            if (workflow.Status >= WorkflowStatus.Completed) completedSteps++;
            if (workflow.Status >= WorkflowStatus.ForwardedToInstallation) completedSteps++;
            if (workflow.Status >= WorkflowStatus.Archived) completedSteps++;
        }

        return (int)Math.Round((double)completedSteps / totalSteps * 100);
    }

    // Animate progress bar to target percentage
    private Task AnimateProgress(int targetPercentage)
    {
        _progressTimer?.Dispose();

        double startValue = _animatedProgress;
        const int animationDurationMs = 1000;
        const int updateIntervalMs = 16;
        int steps = animationDurationMs / updateIntervalMs;
        double increment = (targetPercentage - startValue) / steps;

        _progressTimer = new System.Threading.Timer(async _ =>
        {
            _animatedProgress = Math.Min(_animatedProgress + increment, targetPercentage);
            await InvokeAsync(StateHasChanged);

            if (Math.Abs(_animatedProgress - targetPercentage) < 0.1)
            {
                _animatedProgress = targetPercentage;
                _progressTimer?.Dispose();
                await InvokeAsync(StateHasChanged);
            }
        }, null, 0, updateIntervalMs);

        return Task.CompletedTask;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (ProjectId != Guid.Empty)
        {
            await LoadWorkflows();
            await AnimateProgress(GetCompletionPercentage());
        }
    }

    public void Dispose()
    {
        _progressTimer?.Dispose();
    }
}